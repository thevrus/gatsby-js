{"componentChunkName":"component---src-pages-posts-js","path":"/posts/","result":{"data":{"wpgraphql":{"posts":{"nodes":[{"uri":"javascript-clean-code-error-handling/","id":"cG9zdDoxMA==","title":"JavaScript Clean Code: Error Handling","slug":"javascript-clean-code-error-handling","postId":10,"excerpt":"<p>Error handling is an important part of programs. There are many situations where our programs encounter values that are unexpected and we have to properly handle them. In this article, we’ll look at how to handle them so that errors are easily found easily and gracefully handled. Exceptions are Better than Return Codes Throwing exceptions [&hellip;]</p>\n","content":"\n<p>Error handling is an important part of programs. There are many situations where our programs encounter values that are unexpected and we have to properly handle them.</p>\n\n\n\n<p>In this article, we’ll look at how to handle them so that errors are easily found easily and gracefully handled.</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<h1 id=\"3ff5\">Exceptions are Better than Return Codes</h1>\n\n\n\n<p>Throwing exceptions is better because they let us know that an error exists and that we have to handle it.</p>\n\n\n\n<p>Most modern programming languages have exceptions built-in, so we should throw them instead of returning an error code.</p>\n\n\n\n<p>Error codes aren’t as explicit and may be missed. Exceptions are also much cleaner since we don’t have to check all the codes that may be returned.</p>\n\n\n\n<p>For example, if we return error codes in our functions then we may have code that looks something like this:</p>\n\n\n\n<figure><iframe src=\"https://medium.com/media/814c8dd9c7dd244ad63be32bba596f65\" allowfullscreen=\"\" height=\"527\" width=\"680\"></iframe></figure>\n\n\n\n<p>We have to return all the error codes in our&nbsp;<code>setNumFruit</code>&nbsp;method. Also, before we do something after the class definition, we have to check all the error codes.</p>\n\n\n\n<p>We can throw exceptions instead:</p>\n\n\n\n<figure><iframe src=\"https://medium.com/media/5ff11c42d53e00db8eeedd298ab55c26\" allowfullscreen=\"\" height=\"571\" width=\"680\"></iframe></figure>\n\n\n\n<p>We’ve eliminated the need to check all the error codes by wrapping the code we want to run in a&nbsp;<code>try</code>&nbsp;block. Now we can just catch the error instead of checking all the error codes that may be returned.</p>\n\n\n\n<p>This is much better than checking all error codes before doing something — it’s especially important as code becomes more complex.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://miro.medium.com/max/6540/0*_oeJImio2eNzM8fz\" alt=\"\"/><figcaption>Photo by&nbsp;<a href=\"https://unsplash.com/@xoutcastx?utm_source=medium&amp;utm_medium=referral\" target=\"_blank\" rel=\"noreferrer noopener\">Taylor</a>&nbsp;on&nbsp;<a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\" target=\"_blank\" rel=\"noreferrer noopener\">Unsplash</a></figcaption></figure>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<h1 id=\"1a06\">Write Try-Catch-Finally</h1>\n\n\n\n<p>We should wrap our&nbsp;<code>try</code>&nbsp;in the code that throws exceptions that we want to catch. It creates its own scope for block-scoped variables so anything declared with&nbsp;<code>let</code>&nbsp;or&nbsp;<code>const</code>&nbsp;can only be referenced in the&nbsp;<code>try</code>&nbsp;block.</p>\n\n\n\n<p>Variables declared with&nbsp;<code>var</code>&nbsp;are hoisted so that they can be referenced outside the block. We won’t get an error even if they’re referenced outside the block. This will get us&nbsp;<code>1</code>:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">try {<br>  var x = 1;<br>} catch (ex) {<br>  console.error(ex);<br>}<br>console.log(x);</pre>\n\n\n\n<p>But this will get us&nbsp;<code>Uncaught ReferenceError: x is not defined</code>:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">try {<br>  let x = 1;<br>} catch (ex) {<br>  console.error(ex);<br>}<br>console.log(x);</pre>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<h1 id=\"830b\">Don’t Ignore Caught Errors</h1>\n\n\n\n<p>We should report our errors when they’re caught. They shouldn’t be caught and then ignored. This is because we don’t want to sweep underlying issues under the rug.</p>\n\n\n\n<p>Reporting exceptions let us know about the error and then handle it accordingly.</p>\n\n\n\n<p>The examples above, like the&nbsp;<code>console.error</code>, call in the following:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">try {<br>  const error = fruitStand.setNumFruit(1);<br>  console.log(fruitStand.numFruits);<br>} catch (ex) {<br>  console.error(ex);<br>}</pre>\n\n\n\n<p>Thi s one of the ways to report the error. We can also use other libraries to report the error in a central place.</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<h1 id=\"1b24\">Don’t Ignore Rejected Promises</h1>\n\n\n\n<p>Like any other exception, rejected promises also need to be handled. They can be handled with the callback that we pass into the&nbsp;<code>catch</code>&nbsp;method or use the&nbsp;<code>try...catch</code>&nbsp;block for&nbsp;<code>async</code>&nbsp;functions — they’re the same.</p>\n\n\n\n<p>For example, we can report the error by writing the following:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">Promise.reject('fail')<br>  .catch(err =&gt; {<br>    console.error(err);<br>  })</pre>\n\n\n\n<p>Or for&nbsp;<code>async</code>&nbsp;functions we can write this:</p>\n\n\n\n<pre class=\"wp-block-preformatted\">(async () =&gt; {<br>  try {<br>    await Promise.reject('fail')<br>  } catch (err) {<br>    console.error(err);<br>  }<br>})()</pre>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<h1 id=\"26fe\">Providing Context with Exceptions</h1>\n\n\n\n<p>We should provide enough context in exceptions that other developers can pinpoint the error when an exception is thrown.</p>\n\n\n\n<p>We can get a stack trace with exceptions in JavaScript, but it may not provide all the information we need.</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<h1 id=\"50b1\">Conclusion</h1>\n\n\n\n<p>When we handle errors, throwing exceptions is better than returning error codes since they let us use the&nbsp;<code>try...catch</code>&nbsp;block to handle errors. This is much cleaner than checking multiple error codes.</p>\n\n\n\n<p>When we throw exceptions, we have to provide enough details to pinpoint the problem.</p>\n\n\n\n<p>We shouldn’t just ignore errors after catching them. We should at least report them so that they can be looked at.</p>\n\n\n\n<p>Finally, rejected promise errors should be handled the same way as other exceptions.</p>\n"},{"uri":"refactoring-my-6-favorite-patterns-p13/","id":"cG9zdDox","title":"Refactoring: My 6 favorite patterns","slug":"refactoring-my-6-favorite-patterns-p13","postId":1,"excerpt":"<p>Refactoring code has become one of my favorite things to do as a developer. It can have a major impact on code cleanliness, readability, and maintainability. In this post I’ll outline 6 refactoring patterns that I&#8217;ve found to be very useful and provide examples of each. Many are inspired by Martin Fowler&#8217;s “Refactoring” book, which [&hellip;]</p>\n","content":"\n<p>Refactoring code has become one of my favorite things to do as a developer. It can have a major impact on code cleanliness, readability, and maintainability.</p>\n\n\n\n<p>In this post I’ll outline 6 refactoring patterns that I&#8217;ve found to be very useful and provide examples of each. Many are inspired by Martin Fowler&#8217;s “Refactoring” book, which I highly recommend if you&#8217;re looking to better understand common refactoring patterns.</p>\n\n\n\n<p>(Side note: having good test coverage is also a&nbsp;<em>CRUCIAL</em>&nbsp;part of refactoring, but is outside the scope of this post.)</p>\n\n\n\n<p>While the examples are in JavaScript, each pattern should be applicable to any programming language.</p>\n\n\n\n<h2>6. Introduce Object Parameter</h2>\n\n\n\n<p>When functions have multiple parameters, you start running into a few issues:</p>\n\n\n\n<ol><li>For the function to work correctly, the order of parameters needs to be maintained.</li><li>The names of the&nbsp;<em>arguments</em>&nbsp;(the actual values) passed to a function might not necessarily be the same as the parameter names, which makes searching for certain types of data/logic hard to do.</li><li>Adding/removing parameters is a chore; each use of the function needs to be examined.</li></ol>\n\n\n\n<p>To make function parameters more manageable, this pattern involves converting a list of parameters into a single object. This forces consistent parameter naming across all functions, and makes the parameter order insignificant.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// Before\n\nfunction sayHello(toName, punctuation, fromName) {\n  return `Hello, ${toName}${punctuation} From, ${fromName}.`\n} \n\nsayHello(customerName, end, myName);\n\n// After\n\nfunction sayHello({ toName, punctuation, fromName }) {\n  return `Hello, ${toName}${punctuation} From, ${fromName}.`\n} \n\nsayHello({ toName, punctuation, fromName });\n</code></pre>\n\n\n\n<h2>5. Replace Anonymous Function with Expression</h2>\n\n\n\n<p>In JavaScript it’s a common practice to pass an anonymous function into an array method, such as&nbsp;<code>.map</code>,&nbsp;<code>.reduce</code>, or&nbsp;<code>.filter</code>. One issue I frequently see with these anonymous functions is they become complicated and difficult to parse; and since there is no name for the function it can be difficult to quickly understand the intent of the code.</p>\n\n\n\n<p>Instead, I’ve found it helpful to extract these anonymous functions into a function expression, which makes it much easier to understand the intent (this also resembles &#8220;point-free style&#8221; a.k.a. &#8220;tacit programming&#8221;.).</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// Before\n\nconst activeUsers = users.filter((user) => {\n  if(user.lastPayment >= moment().startOf('week').toDate()) {\n    return true;\n  }\n\n  return false;\n});\n\n// After\n\nconst activeUsers = users.filter(hasUserPaidThisWeek);\n\nfunction hasUserPaidThisWeek(user) {\n  if(user.lastPayment > moment().startOf('week').toDate() ) {\n    return true;\n  }\n\n  return false;\n}\n</code></pre>\n\n\n\n<h2>4. Replace Primitive with Object</h2>\n\n\n\n<p>Using a primitive value such as a string, number, or boolean is a common practice in many programming languages. But problems can arise when requirements and/or rules around these primitive values become more complex.</p>\n\n\n\n<p>Instead of using an uncontrolled primitive value, a helpful practice is to wrap these primitives in an object, which will give you more control over how the value is consumed and modified.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// Before\n\nlet isLoading = true;\n// some code...\nloading = false;\n\nconst phone = '1 617 484-4049';\n\nconst price = 11;\n\n// After\n\nclass LoadingStatus {\n  constructor(initialStatus) {\n    if(!this.statusSet.has(initialStatus)) {\n      throw new Error('Invalid status');\n    } \n\n    this._status = initialStatus;\n  }\n\n  statusSet = new Set(&#91;'loading', 'success', 'error', 'idle'])\n\n  get status() {\n    return this._status;\n  }\n\n  set status(status) {\n    if(!this.statusSet.has(status)) {\n      throw new Error('Invalid status');\n    } \n\n    this._status = status;\n  }\n}\n\nclass Phone {\n  constructor(phone) {\n    this._phone = this.parsePhone(phone);\n  }\n\n  parsePhone(phone) {\n    const trimmedPhone = phone.trim();\n\n    if(phone.length !== 10) {\n      throw new Error('Invalid phone format');\n    }\n\n    const areaCode = trimmedPhone.slice(0,3);\n    const prefix = trimmedPhone.slice(3,7);\n    const lineNumber = trimmedPhone.slice(7, 10);\n\n    return { areaCode, prefix, lineNumber };\n  }\n\n  get areaCode() {\n    return this._phone.areaCode;\n  }\n\n  get formatted() {\n    const { areaCode, prefix, lineNumber } = this._phone;\n\n    return `${areaCode} ${prefix}-${lineNumber}` \n  }\n\n  ...\n}\n\nclass Price {\n  constructor(price) {\n    if(typeof price !== 'string') {\n      throw new Error('Invalid price');\n    }\n\n    if(!(price).match(/^&#91;0-9]*$/)) {\n      throw new Error('Invalid price');\n    }\n\n    this._price = price;\n  }\n\n  get price() {\n    this._price;\n  }\n}\n</code></pre>\n\n\n\n<h2>3. Decompose Conditional</h2>\n\n\n\n<p><code>if/else</code>&nbsp;statements can be a powerful tool when adding logic to your program. But they can also become unwieldy and confusing very quickly. One way to counteract this is by making the conditional logic easier to understand by extracting it into expressions that describe your intent.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// Before\n\nif(user.hasEmail() &amp;&amp; user.subscriptions.includes('email')) {\n  sendEmail(user);\n}\n\n// After\n\nconst isSubscribed = user.hasEmail() &amp;&amp; user.subscriptions.includes('email');\n\nif(isSubscribed) {\n  sendEmail(user);\n}\n</code></pre>\n\n\n\n<h2>2. Encapsulate Record (Bridge Pattern)</h2>\n\n\n\n<p>Most of the time building software involves consuming an existing API and/or providing your own. If your component is coupled with another API and that API changes, you may need to change your component as well; and this can sometimes be very time consuming.</p>\n\n\n\n<p>Instead of coupling various APIs, I find it helpful to give each component an API that makes the most sense given its functionality, and adding a layer in between your component and any other API it is interacting with.</p>\n\n\n\n<p>The Encapsulate Record refactoring pattern provides a great way to do this. This idea is also aligned with the Bridge pattern, which you can learn more about in &#8220;Design Patterns: Elements of Reusable Object-Oriented Software”.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// Before\n\nconst user = {\n  name: 'A Name', \n  favorites: { \n    color: 'blue',\n    food: 'pizza'\n  }\n}\n\nconst UserComponent = (user) => (\n  &lt;div>Name: {user.name} - Food: {user.favorites.food}&lt;/div>\n);\n\nUserComponent(user);\n\n// After\n\nconst user = {\n  name: 'A Name', \n  favorites: { \n    color: 'blue',\n    food: 'pizza'\n  }\n}\n\nclass User {\n  constructor(user) {\n    this._user = user;\n  }\n\n  get name() {\n    return this._user.name;\n  }\n\n  get food() {\n    return this._user.favorites.food;\n  }\n}\n\nconst UserComponent = ({ name, food }) => (\n  &lt;div>Name: {name} - Food: {food}&lt;/div>\n);\n\nUserComponent(new User(user));\n\n</code></pre>\n\n\n\n<h2>1. Replace Conditional with Polymorphism</h2>\n\n\n\n<p>This is probably my favorite refactoring pattern. Several times it has helped me make confusing conditional logic much more readable and maintainable. And once logic is encapsulated in an object, you then have the flexibility to utilize other OOP design patterns to help achieve your goals.</p>\n\n\n\n<p>The idea here is that instead of using a bunch of nested&nbsp;<code>if</code>&nbsp;statements in your code, you create objects that represent different &#8220;types&#8221;, and give each type method(s) that are in charge of performing certain actions. Then, the application can simply call the same method on each type, and it’s up to the type to perform the action in the correct way.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// Before\n\nif(user.favorites.food === 'pizza') {\n  sendPizzaEmail(user);\n}\n\nif(user.favorites.food === 'ice cream') {\n  sendIceCreamEmail(user);\n}\n\n// After\n\nclass PizzaUser {\n  constructor(user) {\n    this._user = user;\n  }\n\n  sendEmail() {\n    sendPizzaEmail(this._user);\n  }\n}\n\nclass IceCreamUser {\n  constructor(user) {\n    this._user = user;\n  }\n\n  sendEmail() {\n    sendIceCreamEmail(this._user);\n  }\n}\n\n// this would create the appropriate user using the above classes\nconst user = getUser(userData); \n\nuser.sendEmail()</code></pre>\n\n\n\n<p></p>\n"}]}}},"pageContext":{}}}